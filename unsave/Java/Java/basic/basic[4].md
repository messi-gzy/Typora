# 基础[4]

- $\textcolor{#e18a3b}{【一】}$**[面向对象（上）](#1)**

<a id="0">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>></a>

## 面向对象（上）

<a id="1">**`目录`**</a>

- $\textcolor{#2a6e3f}{【01】}$ [介绍](#1.1)
- $\textcolor{#2a6e3f}{【02】}$ [概述和结构](#1.2)
- $\textcolor{#2a6e3f}{【03】}$ [类的创建](#1.3)
- $\textcolor{#2a6e3f}{【04】}$ [类中方法](#1.4)
- $\textcolor{#2a6e3f}{【05】}$ [数组对象](#1.5)
- $\textcolor{#2a6e3f}{【06】}$ [封装与隐藏](#1.6)
- $\textcolor{#2a6e3f}{【07】}$ [构造器](#1.7)
- $\textcolor{#2a6e3f}{【08】}$ [this](#1.8)
- $\textcolor{#2a6e3f}{【09】}$ [](#1.9)
- $\textcolor{#2a6e3f}{【10】}$ [](#1.10)
- $\textcolor{#2a6e3f}{【11】}$ [](#1.11)
- $\textcolor{#2a6e3f}{【12】}$ [](#1.12)
- $\textcolor{#2a6e3f}{【13】}$ [](#1.13)
- $\textcolor{#2a6e3f}{【14】}$ [](#1.14)

---

### 1、介绍

<a id="1.1">介绍</a>

#### 1.1、面向对象

> 面向对象就是把数据和操作方法放在一起，作为一个相互依存的整体。面向对象，**将功能封装进对**
> **象，强调具备了功能的对象**，以类/对象为最小单位，考虑谁来做。

**`优点`**

- 易维护、易复用、易拓展
- 三大特性，低耦合

**`缺点`**

- 性能较差，类需要实例化

**`三大特征`**

| 封装 | 继承 | 多态 |
| :--: | :--: | :--: |

- 封装

  ```
  隐藏对象的属性和实现，仅对外提供公共访问方式，便于使用，提高复用性和安全性
  ```

- 继承

  ```
  提高代码的复用性；继承是多态的前提
  ```

- 多态

  ```
  父类或接口定义的引用变量可以指向子类或具体实现类的实例对象。提高了程序的拓展性。
  ```

**`五大基本原则`**

- 单一职责原则（SRP）

  ```
  专门的类干专门的事
  ```

- 开放封闭原则（OCP）

  ```
  一个模块对于拓展是开放的，对于修改是封闭的，
  ```

- 里氏替换原则（LSP）

  ```
  子类可以替换父类出现在父类能够出现的任何地方。
  ```

- 依赖倒置原则（DIP）

  ```
  高层次的模块不应该依赖于低层次的模块，他们都应该依赖于抽象。抽象不应该依赖于具体实现，具体实现应该依赖于抽象。
  ```

- 接口分离原则（ISP）

  ```
  设计时采用多个与特定客户类有关的接口比采用一个通用的接口要好。
  ```

#### 1.2、面向过程

> 面向过程，**强调的是功能行为，以函数为最小单位**，考虑怎么做。过程是具体化的，流程化的，一步一步实现。

**`优点`**

- 性能更高，消耗更低资源

**`缺点`**

- 不易维护，不易复用，不易拓展

#### 1.3、区别

> 面向对象更符合人类的思维，面向过程则是机器的思想

---

### 2、概述和结构

<a id="1.2">概述和结构</a>

#### 2.1、概述

​	**类(Class)和对象(Object)是面向对象的核心概念。 类是对一类事物的描述，==类是抽象的==、概念上的定义 。==对象是实际存在==的该类事物的每个个体，因而也称为实例(instance)。**

​	**==面向对象的程序设计的重点是类的设定==**

#### 2.2、结构

##### 2.2.1、属性

> 成员变量

##### 2.2.2、方法

> 行为

##### 2.2.3、属性和局部变量

1. 相同
   - 格式相同
   - 先声明，后使用
   - 都有作用域
2. 不同

|                  |               位置不同               |     内存位置不同     | 权限修饰符 |            默认初始化            |
| :--------------: | :----------------------------------: | :------------------: | :--------: | :------------------------------: |
|   ==**属性**==   |               类定义中               | **堆区**（除static） |     ~~     |          都有默认初始化          |
| ==**局部变量**== | 方法内，方法形参、代码块内、构造方法 |         栈区         |     ~~     | ==没有默认初始化，必须显示赋值== |

---

### 3、类的创建

<a id="1.3">类的创建</a>

`设计类`

```java
public class Person {
    String name;
    int age;
    public void Eat(){
        age++;
    }
    public String Talk(){
        return this.name;
    }
}
```

`创建对象|实例化对象`

```java
Person person = new Person();
System.out.println(person.Talk());
person.age++;
```

> ==**注意**==
>
> ```java
> Person person1 = new Person(); 
> System.out.println(person1.Talk());//null
> Person person2 = person1; 
> person2.name="jack";
> System.out.println(person1.name);//jack
> ```
>
> **person1将地址赋值给person2，指向同一个实例**

---

### 4、类中方法

<a id="1.4">类中方法</a>

> 描述类具有的功能

#### 4.1、方法声明

```java
[修饰权限符] [其他关键字] 返回值类型 方法名(形参列表...){
		方法体;
}
```

[^其他关键字]: static、abstract、final

#### 4.2、含义

##### 4.2.1、修饰权限符

|    修饰符     | 当前类 | 同包 | 子类 | 其他包 |
| :-----------: | :----: | :--: | :--: | :----: |
|  **private**  |   ✅    |  ❌   |  ❌   |   ❌    |
|  **default**  |   ✅    |  ✅   |  ❌   |   ❌    |
| **protected** |   ✅    |  ✅   |  ✅   |   ❌    |
|  **public**   |   ✅    |  ✅   |  ✅   |   ✅    |

##### 4.2.2、返回值类型

##### 4.2.3、方法名

> 小驼峰命名法

##### 4.2.4、形参列表

##### 4.2.5、方法体

- **方法中可以调用当前类的属性**
- 方法中不可以定义方法

#### 4.3、方法重载

##### 4.3.1、概念

​	在同一个类中，**允许存在一个以上的同名方法，只要它们的参数个数或者参数类型不同即可**。

#####  4.3.2、特点

- ==**与返回值类型无关，只看参数列表，且参数列表必须不同。**==*(参数个数或参数类 型)*

- *==调用时，根据方法参数列表的不同来区别==*
- 跟~~方法的权限修饰符、返回值类型、形参变量名、方法体无关~~

##### 4.3.3、举例

```java
//返回两个整数的和 
int add(int x,int y){return x+y;}
//返回三个整数的和 
int add(int x,int y,int z){return x+y+z;}
```

#### 4.4、可变形参

##### 4.4.1、概念

> java允许将同一个类中多个同名，同功能但参数个数不同的方法封装成一个方法。就可以通过可变参数实现。

`注意`

- 传入的参数是以==**数组的形式传入的**==
- 可变参数和普通参数一起传入时，**可变参数放到最后**
- **一个方法形参中只能申请一个可变形参**

##### 4.4.2、格式

```java
[访问修饰符] 返回值类型 方法名 (数据类型 ... 形参名) 
```

##### 4.4.3、使用

> 访问方式和数组格式相同

```java
public void Hello(String... name) {
    for (int i = 0; i < name.length; i++) {
        System.out.println(name[i]);
    }
}
```

#### 4.5、参数的值传递机制

- ###### ==基本数据类型==

  > **赋值的是变量所保存的==*数据值*==**

- ###### ==引用数据类型==

  > **赋值的是变量所保存的==*地址值*==**

---

### 5、数组对象

<a id="1.5">数组对象</a>

`类数组使用`

```java
Person[] person = new Person[10];
for(int i=0;i<person.length;i++){
    person[i]=new Person();
    person[i].name=i+"..ll";
}
for (Person person1 : person) {
    System.out.println(person1.name);
}
```

`类数组内存解析`

<img src="https://pic1.imgdb.cn/item/6336764916f2c2beb140d25c.png" style="zoom: 60%;" />

---

### 6、封装与隐藏

<a id="1.6">封装与隐藏</a>

> 封装：**隐藏对象内部的复杂性，只对外公开简单的接口**。便于外界调用，从而提高系统的可扩展性、可维护性。
>
> ==**高内聚，低耦合**==
>
> 1. 高内聚 ：类的内部数据操作细节自己完成，不允许外部干涉； 
> 2. 低耦合 ：仅对外暴露少量的方法用于使用。



---

### 7、构造器

<a id="1.7">构造器</a>

##### 7.1、概念

> l定义在类中的，可以用于初始化一个类的对象，并返回对象的地址。

##### 7.2、作用

> - 创建对象
> - 初始化对象属性

##### 7.3、格式

```
修饰符 类名(形参列表){
   ...
}
```

```java
public Person(){};//无参构造器
public Person(String name,int age){//有参构造器
    this.name=name;
    this.age=age;
};
```

`使用`

```
Person person_null = new Person();
Person person_list = new Person("hello",73);
```

##### 7.4、注意

- 构造器的名称必须和类名一致
- 一个类中可以定义多个构造器，但是构造器的参数列表必须不同(重载)
- 如果没有定义构造器，编译器默认提供空的构造器
- 如果定义构造器了，就需要手动自已添加空构造器
- 一个类中至少要有一个构造器
- 构造方法没有返回类型，返回地址

### 8、this

<a id="1.8">this</a>

### 9、

<a id="1.9"></a>

### 10、

<a id="1.10"></a>



### ...其他

#### 1、JavaBean

> 1. 类是公共的 
> 2. 有一个无参的公共的构造器 
> 3. 有属性，且有对应的`get`、`set`方法

#### 2、UML

[<<<<](#0)

---
