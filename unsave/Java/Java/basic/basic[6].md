# 基础[6]

<a id="0">`目录`</a>

- $\textcolor{#e18a3b}{【一】}$**[面向对象（下）](#1)**

## 面向对象（下）

<a id="1"><!--目录--></a>

- $\textcolor{#2a6e3f}{【01】}$ [static](#1.1)
- $\textcolor{#2a6e3f}{【02】}$ [代码块](#1.3)
- $\textcolor{#2a6e3f}{【03】}$ [final](#1.4)
- $\textcolor{#2a6e3f}{【04】}$ [抽象类|方法](#1.5)
- $\textcolor{#2a6e3f}{【05】}$ [接口](#1.6)
- $\textcolor{#2a6e3f}{【06】}$ [内部类](#1.7)
- $\textcolor{#2a6e3f}{【07】}$ [包装类](#1.8)
- $\textcolor{#2a6e3f}{【08】}$ [简单模式](#1.9)

---

### 1、static<a id="1.1">💛</a>

> 开端：我们有时候希望无论是否产生了对象或无论产生了多少对象的情况下，**某些特定的数据在内存空间里只有一份**（唯一）

#### 1.1、介绍

​	静态变量：某些特定的数据在内存中只有一份，而且能被一个类的所有实例对象共享。可以使用类名.变量名的形式来访问。当然也可以先实例化对象在用对象.变量名访问

​	**它可以被类的每个实例化共享访问**

​	注意： static关键字只用于修饰 成员变量，不能用于修饰局部变量

#### 1.2、作用范围

1. **使用范围**：java static关键字可以用在变量、方法、代码块和嵌套类伤。

2. **作用范围**：static关键字属于类，而不是类的实例

   静态(static)修饰如下：

   - 变量：称为类变量、静态变量
   - 方法：称为类方法、静态方法
   - 代码块：称为静态代码块
   - 嵌套类：称为静态内部类

3. 被修饰后的成员具备以下特点：

   - 随着类的加载而加载 
   - 优先于对象存在 
   - 修饰的成员，被所有对象所共享 
   - 访问权限允许时，可不创建对象，直接被类调用

#### 1.3、静态变量

`类变量`（~~实例变量~~）

##### 1、区别

###### 1.1、静态变量

- 运行时，Java 虚拟机只为静态变量分配一次内存，加载类过程中完成静态变量的内存分配。
- 在类的内部，可以在任何方法内直接访问静态变量。
- 在其他类中，可以通过类名访问该类中的静态变量。

###### 1.2、实例变量

- 每创建一个实例，Java 虚拟机就会为实例变量分配一次内存。
- 在类的内部，可以在非静态方法中直接访问实例变量。
- 在本类的静态方法或其他类中则需要通过类的实例对象进行访问。

##### 2、特点

- **静态变量可以被类的所有实例共享**，因此静态变量可以作为实例之间的共享数据，增加实例之间的交互性。
- 如果类的所有实例都包含一个相同的常量属性，则可以把这个属性定义为静态常量类型，从而节省内存空间。

#### 1.4、静态方法

`类方法`（~~实例方法~~）

##### 1、区别

1. 静态方法，属于类，而不属于类的对象。
   - 它通过类直接被调用，无需创建类的对象。
   - **静态方法中，==不能使用 this | super关键字，也不能直接访问所属类的实例变量和实例方法==；**
   - **静态方法中，==可以直接访问所属类的静态变量和静态方法==。**
   - 同this 关键字，super 关键字也与类的实例相关，静态方法中不能使用 super 关键字。
2. 实例方法，可直接访问所属类的静态变量、静态方法、实例变量和实例方法。

##### 2、特点

###### 2.1、优点

1. 属于类级别，无需创建对象就即可直接使用，使用方便。
2. 全局唯一，内存中唯一，静态变量可以唯一标识某些状态。
3. 类加载时候初始化，常驻在内存，调用快捷方便。

###### 2.2、缺点

1. 静态方法不能调用非静态的方法和变量。
2. 不能使用this和super关键字。

###### 2.3、静态方法与静态变量适用场景

1. 静态方法，最适合工具类中方法的定义；比如文件操作，日期处理方法等。
1. 静态方法，适合入口方法定义；比如单例模式，因从外部拿不到构造函数，所以定义一个静态的方法获取对象非常有必要。
1. 静态变量适合全局变量的定义；举例：用一个布尔型静态成员变量做控制标志。

#### 1.5、静态类

​	`java`中一个类要被声明为static的，只有一种情况，就是**静态内部类（内嵌类）**。如在外部类声明为static的，程序会编译都不会通过。

- 静态内部类，跟静态方法一样，只能访问静态成员变量和方法，不能访问非静态方法和属性。
- 普通内部类，可以访问任意外部类的成员变量和方法。
- **静态内部类，可以声明普通成员变量和方法，而普通内部类不能声明static成员变量和方法。**
- 静态内部类，可以单独初始化。

> 静态内部类：
>
> ```java
> Inner i = new Outer.Inner();
> ```
>
> 普通内部类：
>
> ```java
> Outer o = new Outer();
> Inner i = o.new Inner();
> ```

---

### 2、代码块<a id="1.2">💛</a>



---

### 3、final<a id="1.3">💛</a>



---

### 4、抽象类|方法<a id="1.4">💛</a>



---

### 5、接口<a id="1.5">💛</a>



---

### 6、内部类<a id="1.6">💛</a>



---

### 7、包装类<a id="1.7">💛</a>



---

### 8、简单模式<a id="1.8">💛</a>



---

[<!--返回目录-->](#1)

[<!--返回总目录-->](#0)

**[README](../../README.md)**



