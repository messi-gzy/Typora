# 基础[5]

<a id="0">`目录`</a>

- $\textcolor{#e18a3b}{【一】}$**[面向对象（中）](#1)**

## 面向对象（中）

<a id="1"><!--目录--></a>

- $\textcolor{#2a6e3f}{【01】}$ [继承](#1.1)
- $\textcolor{#2a6e3f}{【02】}$ [权限修饰符](#1.2)
- $\textcolor{#2a6e3f}{【03】}$ [方法重写](#1.3)
- $\textcolor{#2a6e3f}{【04】}$ [super](#1.4)
- $\textcolor{#2a6e3f}{【05】}$ [子类对象实例化](#1.5)
- $\textcolor{#2a6e3f}{【06】}$ [多态性](#1.6)
- $\textcolor{#2a6e3f}{【07】}$ [Object类](#1.7)

---

### 1、继承<a id="1.1">💛</a>

**继承是从已有的类创建新类的过程。**

1.  继承是面向对象三大特征之一 。
2. 被继承的类称为父类（超类），继承父类的类称为子类（派生类）。
3. 继承是指一个对象直接使用另一对象的属性和方法。 
4. 通过继承可以实现代码重用。
5. 多个类中存在相同属性和行为时，将这些内容抽取到单独一个类中， 那么多个类无需再定义这些属性和行为，只要继承那个类即可。

#### 1.1、语法规则

```java
[访问权限] class [子类名] extends 父类名{
	类体定义；
}
```

<!--举例-->

```java
public class Animal {
    private int age;
    private String name;
    protected char sex;
}

public class Cut extends Animal{
    public void testArea(){
        System.out.println(this.sex);
    }
}
```

#### 1.2、继承规则

<mark>**继承性**</mark>

- Java只能实现单继承，也就是一个类只能有一个父类
- 子类继承了父类，就继承了父类的方法和属性。
- 在子类中，可以使用父类中定义的方法和属性，**也可以创建新的数据和方法**。
- **允许多层继承**，不可以多重继承（一个子类多个父类）即：一个子类可以有一个父类，一个父类还可以有其他的父类。
- **继承只能继承非私有的属性和方法。** **子类不能直接访问父类中私有的(private)的成员变量和方法。**
- **构造方法不能被继承**

#### 1.3、继承作用

- 继承的出现减少了代码冗余，提高了代码的复用性。 
- 继承的出现，更有利于功能的扩展。
- 继承的出现让类与类之间产生了关系，提供了多态的前提。

`缺点`

增强了类与类之间的耦合性，开发原则：高内聚，低耦合

---

### 2、权限修饰符<a id="1.2">💛</a>

|    修饰符     | 当前类 | 同包 | 子类 | 其他包 |
| :-----------: | :----: | :--: | :--: | :----: |
|  **private**  |   ✅    |  ❌   |  ❌   |   ❌    |
|  **default**  |   ✅    |  ✅   |  ❌   |   ❌    |
| **protected** |   ✅    |  ✅   |  ✅   |   ❌    |
|  **public**   |   ✅    |  ✅   |  ✅   |   ✅    |

---

### 3、方法重写<a id="1.3">💛</a>

#### 3.1、定义

​	在子类中可以根据需要对从父类中继承来的方法进行改造，也称为方法的重置、覆盖。**在程序执行时，子类的方法将覆盖父类的方法。**

#### 3.2、规则

- 子类重写的方法必须和父类被重写的方法**具有相同的方法名称、参数列表** 

- 子类重写的方法的返回值类型不能大于父类被重写的方法的返回值类型 

- 子类重写的方法使用的访问权限不能小于父类被重写的方法的访问权限 

  **子类不能重写父类中声明为private权限的方法**

- 子类方法抛出的异常不能大于父类被重写方法的异常

#### 3.3、举例

```java
public void showMsg(int place) {
        System.out.println(this.age+"\t"+this.name+"\t"+this.sex+"\t"+place);
}
```

```java
public void showMsg(int place){
    System.out.println(this.sex+"\t"+place);
}
```

---

### 4、super<a id="1.4">💛</a>

#### 4.1、介绍

super表示超类（就是我们俗称的父类），当子类需要引用父类的字段时，我们就可以使用

**this表示当前对象 使用super来调用父类的属性，方法，和构造方法**

#### 4.2、使用

1. 使用super调用父类中的属性，可以从父类实例处获得信息。
2. **使用super调用父类中的方法，可以委托父类对象帮助完成某件事情。**
3. 使用super调用父类中的构造方法（super(实参)形式），必须在子类构造方法的第一条语句，调用父类中相应 的构造方法，若不显示的写出来，默认调用父类的无参构造方法，比如：super();

**super VS this**

- 代表的对象不同：
  - this：本身调用者这个对象
  - super：代表父类对象的应用
- 前提：
  - this：没有继承也可以使用
  - super：只能在继承条件才可以使用
- 构造方法：
  - this() ：本类的构造
  - super() ：父类的构造

```java
public Cut(){
    super();
}
```

#### 4.3、注意

- super调用父类的构造方法，**必须在构造方法的第一行**
- super 必须也只能出现在子类的方法或者构造方法中！
- **super 和 this 不能同时调用构造方法！因为this 和 super都必须在方法的第一行。**

---

### 5、子类对象实例化<a id="1.5">💛</a>

#### 5.1、从结果上来看：（继承性）

- 子类继承父类以后，就获取了父类中声明的属性或方法。
- 创建子类的对象，在堆空间中，就会加载所有父类中声明的属性。

#### 5.2、从过程上来看：

- **当我们通过子类的构造器创建子类对象时，我们一定会直接或间接的调用其父类的构造器**，进而调用父类的父类的构造器，…直到调用了java.lang.Object类中空参的构造器为止。正因为加载过所有的父类的结构，所以才可以看到内存中有父类中的结构，子类对象才可以考虑进行调用。
- <mark>**子类实例化不会实例化父类**</mark>

---

### 6、多态性<a id="1.6">💛</a>

#### 6.1、概念

多态性，是面向对象中最重要的概念，在Java中的体现： 

对象的多态性：

- 父类的引用指向子类的对象 

- 可以直接应用在抽象类和接口上

**同类型的对象，执行同一个任务，会表现出不同的行为特征。**

#### 6.2、前提

**有继承/实现关系；有父类引用指向子类对象；<mark>有方法重写。</mark>**

#### 6.3、举例

```java
Animal animal = new Cut();
animal.showMsg(10);
```

<!---格式-->

```java
父类类型 对象名称 = new 子类构造器
   接口 对象名称 = new 实现类构造器
```

#### 6.4、访问特点

- **方法调用：编译看左边，运行看右边。**

- **变量调用：编译看左边，运行也看左边。（<mark>多态侧重行为多态</mark>）**

  > 成员变量：不具备多态性，只看引用变量所声明的类。

#### 6.5、优缺点

##### 1、优点

- 在多态形式下，右边对象可以实现解耦合，便于扩展和维护
- 提高了代码的通用性，常称作接口重用
- 定义方法的时候，使用父类作为参数，该方法就可以接受这父类的一切子类对象，体现出多态的扩展性与便利。

##### 2、缺点

- 多态不能使用子类的独有功能。

#### 6.6、类型转换

##### 1、基本数据类型转换

###### 1.1、自动类型转换：

小的数据类型可以自动转换成大的数据类型 

如 ： long g=20;double d=12.0f

###### 1.2、强制类型转换：

可以把大的数据类型强制转换(casting)成小的数据类型 

如 float f=(float)12.0; int a=(int)1200L

##### 2、引用类型强制转换

- 从子类到父类的类型转换可以自动进行 ‘
- 从父类到子类的类型转换必须通过造型(强制类型转换)实现 
- 无继承关系的引用类型间的转换是非法的 
- 在造型前可以使用**instanceof**操作符测试一个对象的类型

#### 6.7、instanceof

```sql
# x instanceof A：检验x是否为类A的对象，返回值为boolean型。 
```

- 要求x所属的类与类A必须是子类和父类的关系，否则编译错误。 
- 如果x属于类A的子类B，**x instanceof A值也为true。**

```java
public class Person extends Object {…} 
public class Student extends Person {…}
public class Graduate extends Person {…}
------------------------------------------------------------------
public void method1(Person e) { 
    if (e instanceof Person) 
        // 处理Person类及其子类对象
	if (e instanceof Student)
        //处理Student类及其子类对象
	if (e instanceof Graduate)
        //处理Graduate类及其子类对象
}
```

#### 6.8、类型转换举例

```java
Animal animal = (Animal) new Cut();
animal.showMsg(10);
if (animal instanceof Cut) {
    Cut cut = (Cut) animal;
    cut.testArea();
}
```

---

### 7、Object类<a id="1.7">💛</a>

#### 7.1、介绍

​	Object类是Javajava.lang包下的核心类，**Object类是所有类的父类**，何一个类时候如果没有明确的继承一个父类的话，那么它就是Object的子类；

<!--同种含义--->

```java
class Person { }

class Person extends Object { }
```

![](https://pic.imgdb.cn/item/6391e0d8b1fccdcd3632e60f.jpg)

[^iqqcode]: 图片来源CSDN作者 iqqcode

#### 7.2、常用方法

##### 1、clone()

实现对象的浅复制，只有实现了Cloneable接口才可以调用该方法，否则抛出CloneNotSupportedException异常。

##### 2、getClass()

final方法，返回Class类型的对象，反射来获取对象。

##### 3、toString()

来获取对象的信息。取得对象信息，返回该对象的字符串表示

![](https://pic.imgdb.cn/item/6391e46fb1fccdcd363d38be.png)

> 默认输出对象在堆内存上的地址值

##### 4、finalize()

该方法用于释放资源。因为无法确定该方法什么时候被调用，很少使用。

##### 5、equals()

比较对象的内容是否相等

##### 6、hashCode()

​	该方法用于哈希查找，重写了equals方法一般都要重写hashCode方法。这个方法在一些具有哈希功能的Collection中用到。

##### 7、wait()

wait方法就是使**当前线程等待该对象的锁**，当前线程必须是该对象的拥有者，也就是具有该对象的锁。wait()方法一直等待，直到获得锁或者被中断。wait(long timeout)设定一个超时间隔，如果在规定时间内没有获得锁就返回。

调用该方法后当前线程进入睡眠状态，直到以下事件发生。

1. 其他线程调用了该对象的**notify**方法。
2. 其他线程调用了该对象的**notifyAll**方法。
3. 其他线程调用了**interrupt**中断该线程。
4. 时间间隔到了。

此时该线程就可以被调度了，如果是被中断的话就抛出一个**InterruptedException**异常。

##### 8、notify()

该方法唤醒在该对象上等待的**某个线程**。

##### 9、notifyAll()

该方法唤醒在该对象上等待的**所有线程**。

##### 10、equals()

对象比较

- **基本数据类型**的比较用 == (如： a == 3，b == 4, a == b，比较的是值是否相等）
- **引用类型数据**比较：调用 equals()方法进行比较

> ==默认直接调用equals()方法会默认**进行比较的是两个对象的地址**==

---

[<!--返回目录-->](#1)

[<!--返回总目录-->](#0)

**[README](../../README.md)**



